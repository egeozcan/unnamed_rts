import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const IMPORT_MARKER = '// @ai-implementation-imports';
const LIST_MARKER = '    // @ai-implementation-list';

function toSlug(input: string): string {
    return input
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
}

function toPascalCase(slug: string): string {
    return slug
        .split('_')
        .filter(Boolean)
        .map(part => part[0].toUpperCase() + part.slice(1))
        .join('');
}

function fail(message: string): never {
    console.error(`Error: ${message}`);
    process.exit(1);
}

function createFile(filePath: string, contents: string): void {
    if (fs.existsSync(filePath)) {
        fail(`File already exists: ${filePath}`);
    }
    fs.writeFileSync(filePath, contents, 'utf8');
}

function updateRegistry(registryPath: string, symbolName: string, slug: string): void {
    let source = fs.readFileSync(registryPath, 'utf8');
    const importLine = `import { ${symbolName} } from './implementations/${slug}/index.js';`;

    if (!source.includes(IMPORT_MARKER) || !source.includes(LIST_MARKER)) {
        fail(`Registry markers were not found in ${registryPath}`);
    }

    if (!source.includes(importLine)) {
        source = source.replace(IMPORT_MARKER, `${IMPORT_MARKER}\n${importLine}`);
    }

    if (!source.includes(`    ${symbolName},`)) {
        source = source.replace(LIST_MARKER, `    ${symbolName},\n${LIST_MARKER}`);
    }

    fs.writeFileSync(registryPath, source, 'utf8');
}

function main(): void {
    const rawName = process.argv[2];
    if (!rawName) {
        fail('Usage: npm run ai:new -- <name>');
    }

    const slug = toSlug(rawName);
    if (!slug) {
        fail(`Could not derive a valid slug from "${rawName}"`);
    }

    if (slug === 'classic') {
        fail('"classic" is reserved for the built-in implementation');
    }

    const pascalName = toPascalCase(slug);
    const symbolName = `${pascalName}AIImplementation`;
    const computeName = `compute${pascalName}AiActions`;

    const thisFile = fileURLToPath(import.meta.url);
    const repoRoot = path.resolve(path.dirname(thisFile), '..', '..');

    const implementationDir = path.join(repoRoot, 'src', 'engine', 'ai', 'implementations', slug);
    const implementationIndex = path.join(implementationDir, 'index.ts');
    const implementationReadme = path.join(implementationDir, 'README.md');
    const implementationState = path.join(implementationDir, 'state.ts');
    const registryPath = path.join(repoRoot, 'src', 'engine', 'ai', 'registry.ts');
    const testPath = path.join(repoRoot, 'tests', 'engine', `ai_${slug}.test.ts`);

    if (fs.existsSync(implementationDir)) {
        fail(`Implementation directory already exists: ${implementationDir}`);
    }

    fs.mkdirSync(implementationDir, { recursive: true });

    createFile(
        implementationIndex,
        `import { Action, GameState } from '../../../types.js';
import { AIImplementation, AIImplementationDifficulty } from '../../contracts.js';

export function ${computeName}(state: GameState, playerId: number, difficulty: AIImplementationDifficulty): Action[] {
    // TODO: Replace with your strategy logic.
    void state;
    void playerId;
    void difficulty;
    return [];
}

export const ${symbolName}: AIImplementation = {
    id: '${slug}',
    name: '${pascalName}',
    description: 'New AI implementation scaffold.',
    computeActions: ({ state, playerId, difficulty }) => ${computeName}(state, playerId, difficulty)
};
`
    );

    createFile(
        implementationState,
        `export interface ${pascalName}AIState {
    initializedAtTick: number;
}

export function createInitial${pascalName}AIState(): ${pascalName}AIState {
    return {
        initializedAtTick: 0
    };
}
`
    );

    createFile(
        implementationReadme,
        `# ${pascalName} AI

This folder was generated by \`npm run ai:new -- ${slug}\`.

## Files

- \`index.ts\`: main implementation entry point.
- \`state.ts\`: local state helpers for this implementation.

## Next Steps

1. Implement strategy logic in \`index.ts\`.
2. Add behavior-specific tests in \`/tests/engine/ai_${slug}.test.ts\`.
3. Run \`npm test\`.
`
    );

    createFile(
        testPath,
        `import { describe, it, expect } from 'vitest';
import { getAIImplementation } from '../../src/engine/ai/registry.js';

describe('${pascalName} AI scaffolding', () => {
    it('registers in the AI registry', () => {
        const implementation = getAIImplementation('${slug}');
        expect(implementation).toBeDefined();
        expect(implementation?.id).toBe('${slug}');
    });
});
`
    );

    updateRegistry(registryPath, symbolName, slug);

    console.log(`Created AI implementation scaffold "${slug}"`);
    console.log(`- ${implementationIndex}`);
    console.log(`- ${implementationState}`);
    console.log(`- ${implementationReadme}`);
    console.log(`- ${testPath}`);
    console.log(`Updated registry: ${registryPath}`);
}

main();
